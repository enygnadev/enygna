PROMPT — Next.js (App Router) + Firebase seguro e poderoso

Você é um agente sênior. Use Extended Thinking e High-Power Model. Não remova nada que já funciona – apenas refatore com segurança. Objetivo: deixar o app seguro, performático e sem erros de permissão em páginas públicas.

Contexto do projeto

Stack: Next.js (App Router) + Firebase (Auth, Firestore, Storage) + Vercel.

Páginas públicas (sem login):

/home, /planos, /sistemas

Páginas protegidas (exigem login):

/chamados/auth (+ /chamados/auth/admin)

/crm/auth

/documentos/auth

/financeiro/auth (+ /financeiro/auth/admin)

/frota/auth (+ /frota/auth/admin)

/ponto/auth

/admin/auth

Pastas informadas (exemplos):

app/chamados/auth/page.tsx
app/chamados/auth/admin/page.tsx
app/crm/auth/page.tsx
app/documentos/auth/page.tsx
app/financeiro/auth/page.tsx
app/financeiro/auth/admin/page.tsx
app/frota/auth/page.tsx
app/frota/auth/admin/page.tsx
app/ponto/auth/page.tsx
app/admin/auth/page.tsx

Regras

Não quebrar build. Se algo falhar, crie feat/secure-hardening e commits pequenos e reversíveis.

Sem remoções agressivas. Se precisar mudar muito, isole em rotas/arquivos novos.

Zero erro de permissão nas páginas públicas (não executar queries que exijam auth nessas páginas).

Multi-tenant por empresaId via custom claims (ex.: request.auth.token.empresaId, request.auth.token.role).

Tarefas (passo a passo)
1) Infra e higiene

Ajuste Node para 22.x (Vercel/engines/vercel.json), mantenha lockfile versionado.

Adicione npm run typecheck e npm run audit:prod no CI.

Habilite headers de segurança no next.config.js (CSP, HSTS, nosniff, referrer, permissions).

2) Roteamento público vs protegido (App Router)

Crie grupos de rota:

app/(public)/home/page.tsx

app/(public)/planos/page.tsx

app/(public)/sistemas/page.tsx

app/(protected)/... para todas as rotas de /auth listadas.

No grupo (protected), adicione layout.tsx com guard de autenticação:

Em SSR: se não houver cookie de sessão válido (__session), redirect para /login.

Em CSR: exibir skeleton até confirmar auth/claims (evitar que componentes disparem queries antes do token).

Garanta que páginas públicas não importem hooks que iniciem Firestore listeners sem usuário.

3) Sessão segura (Firebase Admin + Session Cookie)

Crie app/api/session/route.ts:

POST: recebe idToken do cliente, usa Firebase Admin para criar Session Cookie com expiração (ex.: 7 dias), seta cookie __session (HTTPOnly, Secure, SameSite=Lax).

DELETE: invalida sessão (clear cookie).

No login do cliente (Firebase JS), após signInWithEmailAndPassword:

Faça getIdToken(true) e depois fetch('/api/session', { method: 'POST', body: JSON.stringify({ idToken }) }) para promover sessão a cookie.

Middleware opcional: se existir middleware.ts, exclua (public) do check e redirecione /app/(protected) sem __session.

4) Claims de função e empresa

Garanta endpoint admin (somente server) para setar custom claims (empresaId, role), ex.: app/api/admin/set-claims/route.ts (POST: uid, empresaId, role).

No client, carregue getIdTokenResult e cache claims em contexto (AuthContext).

5) Firestore Rules (produção, sem erro em públicos)

Publique rules abaixo (ajuste nomes de coleções se necessário).

IMPORTANTE: coleções públicas como Publico e Site devem ser somente leitura.

Coleções multi-tenant: prefixo Empresas/{empresaId}/....

rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function authed() {
      return request.auth != null;
    }

    function hasRole(roles) {
      return authed() && (request.auth.token.role in roles);
    }

    function sameCompany(empId) {
      return authed() && request.auth.token.empresaId == empId;
    }

    // PÚBLICO (apenas leitura)
    match /Publico/{docId} {
      allow read: if true;
      allow write: if false;
    }

    match /Site/{document=**} {
      allow read: if true;
      allow write: if false;
    }

    // EXEMPLOS multi-tenant — ajuste nomes conforme seu schema real
    match /Empresas/{empresaId}/Chamados/{docId} {
      allow read, create, update: if sameCompany(empresaId) && hasRole(['adminmaster','admin','gestor','colaborador']);
      allow delete: if sameCompany(empresaId) && hasRole(['adminmaster','admin']);
    }

    match /Empresas/{empresaId}/CRM/{docId} {
      allow read, create, update: if sameCompany(empresaId) && hasRole(['adminmaster','admin','gestor','colaborador']);
      allow delete: if sameCompany(empresaId) && hasRole(['adminmaster','admin']);
    }

    match /Empresas/{empresaId}/Financeiro/{docId} {
      allow read, create, update: if sameCompany(empresaId) && hasRole(['adminmaster','admin','gestor']);
      allow delete: if sameCompany(empresaId) && hasRole(['adminmaster']);
    }

    match /Empresas/{empresaId}/Frota/{docId} {
      allow read, create, update: if sameCompany(empresaId) && hasRole(['adminmaster','admin','gestor','colaborador']);
      allow delete: if sameCompany(empresaId) && hasRole(['adminmaster','admin']);
    }

    match /Empresas/{empresaId}/Ponto/{docId} {
      allow read, create, update: if sameCompany(empresaId) && hasRole(['adminmaster','admin','gestor','colaborador']);
      allow delete: if sameCompany(empresaId) && hasRole(['adminmaster','admin']);
    }

    match /Empresas/{empresaId}/Admin/{docId} {
      allow read, write: if sameCompany(empresaId) && hasRole(['adminmaster','admin']);
    }

    // Negar tudo que não foi mapeado
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

6) Storage Rules (público vs. empresa)
rules_version = '2';

service firebase.storage {
  match /b/{bucket}/o {

    function authed() {
      return request.auth != null;
    }

    function sameCompany(empId) {
      return authed() && request.auth.token.empresaId == empId;
    }

    // Público somente leitura
    match /public/{all=**} {
      allow read: if true;
      allow write: if false;
    }

    // Arquivos por empresa
    match /empresas/{empresaId}/{all=**} {
      allow read, write: if sameCompany(empresaId) && request.resource.size < 20 * 1024 * 1024;
    }
  }
}

7) Guard no grupo (protected)

Em app/(protected)/layout.tsx (Server Component):

Leia cookies() e verifique __session.

Se ausente → redirect('/login').

Nunca renderize filhos que disparam Firestore antes da confirmação.

Em componentes cliente, proteja queries:

const { user, claimsLoaded } = useAuthContext();
if (!claimsLoaded) return <Skeleton />;
if (!user) redirect('/login');
// Só então inicie queries do Firestore

8) Headers de segurança (Next)

Aplique no next.config.js:

const securityHeaders = [
  { key: 'Content-Security-Policy', value:
    "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https://firestore.googleapis.com https://identitytoolkit.googleapis.com https://securetoken.googleapis.com; frame-ancestors 'none'; base-uri 'none'; object-src 'none';" },
  { key: 'Strict-Transport-Security', value: 'max-age=63072000; includeSubDomains; preload' },
  { key: 'X-Content-Type-Options', value: 'nosniff' },
  { key: 'Referrer-Policy', value: 'no-referrer' },
  { key: 'Permissions-Policy', value: 'geolocation=(), microphone=(), camera=()' },
];

module.exports = {
  async headers() { return [{ source: '/(.*)', headers: securityHeaders }]; },
};

9) Critérios de aceite (automáticos)

✅ /home, /planos, /sistemas abrem sem login e sem erros de Firestore (nenhuma query protegida é executada nelas).

✅ Qualquer rota em /(protected) redireciona para /login quando não autenticado.

✅ Após login + sessão criada (cookie __session), rotas protegidas funcionam e não dão Missing or insufficient permissions.

✅ Acesso a coleções respeita empresaId e role conforme rules.

10) Entregáveis

app/(public) e app/(protected) criados e funcionando.

app/api/session/route.ts implementado (POST cria cookie, DELETE sai).

app/api/admin/set-claims/route.ts para setar claims com Admin SDK.

middleware.ts (opcional) só se for realmente necessário.

firebase.rules (Firestore) e storage.rules (Storage) aplicados.

next.config.js com security headers.

Documentação curta em SECURITY.md explicando fluxo de sessão, claims e boas práticas.

Observações importantes

Não execute consultas protegidas em páginas públicas.

Não exponha chaves/segredos no client (sem NEXT_PUBLIC_ para segredos).

Se existirem coleções adicionais (ex.: Documentos), mapear no mesmo padrão das rules acima.

Implemente tudo. Depois, rode:

npm run build

npm run typecheck

Teste navegação pública e privada.

Confirme cookies e redirecionamentos.

Snippets úteis para o agente (pode criar/ajustar)

app/api/session/route.ts (exemplo simplificado)

import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';
import admin from '@/lib/firebaseAdmin'; // inicialize Admin SDK

export async function POST(req: Request) {
  const { idToken } = await req.json();
  const expiresIn = 60 * 60 * 24 * 7 * 1000; // 7 dias
  const sessionCookie = await admin.auth().createSessionCookie(idToken, { expiresIn });
  cookies().set('__session', sessionCookie, { httpOnly: true, secure: true, sameSite: 'lax', path: '/' });
  return NextResponse.json({ ok: true });
}

export async function DELETE() {
  cookies().set('__session', '', { httpOnly: true, secure: true, sameSite: 'lax', path: '/', maxAge: 0 });
  return NextResponse.json({ ok: true });
}


app/(protected)/layout.tsx (server)

import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';

export default function ProtectedLayout({ children }: { children: React.ReactNode }) {
  const hasSession = cookies().get('__session')?.value;
  if (!hasSession) redirect('/login');
  return <>{children}</>;
}


Guard no client (exemplo)

const ProtectedClient: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { user, claimsLoaded } = useAuthContext();
  if (!claimsLoaded) return <div>Carregando...</div>;
  if (!user) { if (typeof window !== 'undefined') location.href = '/login'; return null; }
  return <>{children}</>;
};