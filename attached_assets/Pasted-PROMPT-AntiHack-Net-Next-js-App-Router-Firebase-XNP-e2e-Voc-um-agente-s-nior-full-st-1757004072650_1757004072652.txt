PROMPT — AntiHack Net + Next.js (App Router) + Firebase + XNP (e2e)

Você é um agente sênior full-stack + red-team. Use Extended Thinking e High-Power Model. Não quebre nada que já funciona: trabalhe em branch feat/secure-hardening-xnp, com commits pequenos e revertíveis. Objetivo:

Endurecer o app contra invasores experientes, mantendo acessibilidade pública (login aberto).

Implementar XNP: eXclusive Network Protocol — um “clone” de comportamentos TCP/IP na camada de aplicação via WebSockets (compatível Vercel), com: segmentation (chunking), janela deslizante, Selective Repeat ARQ, Forward Error Correction (FEC) (Reed-Solomon ou Fountain), ACK/NACK, reordenação, detecção de duplicata, congestion/flow control adaptativo, QoS por plano, bus interno, reassemblagem, AI Recovery opcional para fluxos tolerantes a predição (texto/telemetria).

Páginas /auth são públicas (UI de login visível sem login), mas qualquer dado protegido só carrega após autenticar + claims.

Segurança: Session Cookie HTTPOnly, CSP/HSTS/nosniff/COOP/CORP, rate-limit, anti-brute-force, honeypots, MFA para admins, rules fortes em Firestore/Storage.

Entregar testes automáticos (unitários, integração, fuzz, property-based) e CI.

1) Infra/Setup

Atualize Node para 22.x (Vercel Project Settings/engines, vercel.json se aplicável).

Scripts no package.json:

"typecheck": "tsc -p . --noEmit", "lint",

"test": "vitest run", "test:watch": "vitest",

"test:fuzz": "vitest run -t fuzz",

"audit:prod": "npm audit --omit=dev".

Dependências (podem variar, escolha estáveis e auditadas):

XNP: ws, nanoid, crc-32, @stablelib/chacha20poly1305 (ou tweetnacl), fastestsmallesttextencoderdecoder, p-limit.

FEC: reed-solomon (ou implemente Fountain simples).

Property-based: fast-check.

Testing: vitest, @vitest/coverage-v8.

Rate-limit: ioredis (Upstash/Redis) com fallback LRU in-memory.

Security headers: sem lib—configure em next.config.js.

Firebase: firebase, firebase-admin.

2) Estrutura de pastas (criar/ajustar)
/app
  /(public)/home/page.tsx
  /(public)/planos/page.tsx
  /(public)/sistemas/page.tsx
  /(public)/login/page.tsx
  /chamados/auth/page.tsx
  /crm/auth/page.tsx
  /documentos/auth/page.tsx
  /financeiro/auth/page.tsx
  /financeiro/auth/admin/page.tsx
  /frota/auth/page.tsx
  /frota/auth/admin/page.tsx
  /ponto/auth/page.tsx
  /admin/auth/page.tsx
  /(protected)/...  ← (apenas se houver telas 100% internas pós-login)
  /api/session/route.ts
  /api/admin/set-claims/route.ts
  /api/xnp/signaling/route.ts        ← sinalização WS
  /api/xnp/honeypot/route.ts         ← honeypot
/lib
  /firebase.ts
  /firebaseAdmin.ts
  /authContext.tsx
  /security/ratelimit.ts
  /security/turnstile.ts
  /security/csrf.ts
  /xnp/transport.ts                  ← client/server core
  /xnp/fec.ts                        ← FEC util
  /xnp/bus.ts                        ← EventBus
  /xnp/assembler.ts                  ← reassemblagem
  /xnp/qos.ts                        ← perfis por plano
  /xnp/ai-recovery.ts                ← heurística/LLM opcional
  /xnp/sim/lossy-sim.ts              ← simulador de perda/latência
/tests
  xnp.transport.spec.ts
  xnp.fec.spec.ts
  xnp.assembler.spec.ts
  xnp.qos.spec.ts
  xnp.fuzz.spec.ts
SECURITY.md
firebase.rules
storage.rules
next.config.js

3) Páginas públicas com /auth público

Todas as rotas /.../auth/page.tsx ficam acessíveis sem login (renderizam UI de login e instruções).

O conteúdo privado carrega só após user && claimsLoaded via dynamic import (sem SSR), p.ex.:

// app/chamados/auth/page.tsx
'use client';
import dynamic from 'next/dynamic';
import { useAuthContext } from '@/lib/authContext';
const Privado = dynamic(() => import('./_privado'), { ssr: false });

export default function Page() {
  const { user, claimsLoaded } = useAuthContext();
  return (
    <div>
      <LoginBox />  {/* sempre público */}
      {user && claimsLoaded ? <Privado /> : <DicaPosLogin />}
    </div>
  );
}

4) Sessão segura (cookies) + anti-brute-force

app/api/session/route.ts:

POST { idToken, turnstileToken, csrf } → createSessionCookie (7 dias).
Cookie: __Host-nextSession (HttpOnly; Secure; Path=/; SameSite=Lax).
Verificar Turnstile/ReCAPTCHA e CSRF; aplicar rate-limit por IP (Redis/Upstash; fallback LRU).

DELETE → limpa cookie (logout).

Fluxo client: após signInWithEmailAndPassword, chamar getIdToken(true) e depois POST /api/session. Nunca usar localStorage para tokens.

5) Claims multi-tenant e papéis

app/api/admin/set-claims/route.ts (server-only, key + allowlist IP): define empresaId e role (adminmaster|admin|gestor|colaborador|viewer).

authContext.tsx expõe { user, claims, claimsLoaded }.

6) Firestore/Storage Rules (produção)

firebase.rules

// Firestore
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function authed() { return request.auth != null; }
    function hasRole(r) { return authed() && (request.auth.token.role in r); }
    function sameCompany(empId) { return authed() && request.auth.token.empresaId == empId; }

    // Público somente leitura
    match /Publico/{docId}            { allow read: if true;  allow write: if false; }
    match /Site/{document=**}         { allow read: if true;  allow write: if false; }

    // Multi-tenant — ajuste coleções reais
    match /Empresas/{empresaId}/Chamados/{docId} {
      allow read, create, update: if sameCompany(empresaId) && hasRole(['adminmaster','admin','gestor','colaborador']);
      allow delete:              if sameCompany(empresaId) && hasRole(['adminmaster','admin']);
      allow create: if request.resource.data.empresaId == empresaId;
      allow update: if resource.data.empresaId == empresaId && request.resource.data.empresaId == empresaId;
    }

    match /Empresas/{empresaId}/CRM/{docId} {
      allow read, create, update: if sameCompany(empresaId) && hasRole(['adminmaster','admin','gestor','colaborador']);
      allow delete:              if sameCompany(empresaId) && hasRole(['adminmaster','admin']);
    }

    match /Empresas/{empresaId}/Financeiro/{docId} {
      allow read, create, update: if sameCompany(empresaId) && hasRole(['adminmaster','admin','gestor']);
      allow delete:              if sameCompany(empresaId) && hasRole(['adminmaster']);
    }

    match /Empresas/{empresaId}/Frota/{docId} {
      allow read, create, update: if sameCompany(empresaId) && hasRole(['adminmaster','admin','gestor','colaborador']);
      allow delete:              if sameCompany(empresaId) && hasRole(['adminmaster','admin']);
    }

    match /Empresas/{empresaId}/Ponto/{docId} {
      allow read, create, update: if sameCompany(empresaId) && hasRole(['adminmaster','admin','gestor','colaborador']);
      allow delete:              if sameCompany(empresaId) && hasRole(['adminmaster','admin']);
    }

    match /Empresas/{empresaId}/Admin/{docId} {
      allow read, write: if sameCompany(empresaId) && hasRole(['adminmaster','admin']);
    }

    // Fechar o restante
    match /{document=**} { allow read, write: if false; }
  }
}


storage.rules

// Storage
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    function authed() { return request.auth != null; }
    function sameCompany(empId) { return authed() && request.auth.token.empresaId == empId; }

    match /public/{all=**} { allow read: if true; allow write: if false; }
    match /empresas/{empresaId}/{all=**} {
      allow read, write: if sameCompany(empresaId) && request.resource.size < 20 * 1024 * 1024;
    }
  }
}

7) XNP — Protocolo de Rede Exclusivo (sobre WebSockets)
Objetivo

Fornecer um transporte confiável/adaptativo no nível da aplicação (compatível com Vercel), “clonando” comportamentos cruciais do TCP/IP:

Segmentation/Chunking de payloads grandes em blocos menores.

Janela deslizante com Selective Repeat ARQ (ACK/NACK por chunk).

FEC (ex.: Reed-Solomon ou Fountain) para tolerar perdas sem retransmissão.

Reordenação e deduplicação por msgId + seq.

Congestion/Flow control: ajuste dinâmico de tamanho de janela e taxa com base em RTT/perda.

QoS por Plano: a cada novo plano, selecionar nova escala de parâmetros (perfil) — ex.: Bronze/Prata/Ouro/Platina controlando taxa/janela/FEC.

Bus interno de eventos (/lib/xnp/bus.ts) — Pub/Sub de mensagens.

AI Recovery (opcional): quando faltar chunks e estiver abaixo de um limite de “incompletude”, use heurística/LLM para prever/estimar trechos (só para tipos tolerantes a predição: texto/telemetria).

Componentes (implementar)

/lib/xnp/transport.ts

API:

type QoSProfile = 'bronze'|'prata'|'ouro'|'platina';
interface XnpOptions { qos: QoSProfile; fecRate?: number; maxWindow?: number; }
interface Xnp {
  connect(url: string, opts: XnpOptions): Promise<void>;
  send(message: Uint8Array|string, meta?: Record<string,any>): Promise<string>; // retorna msgId
  on(event: 'message'|'ack'|'nack'|'open'|'close'|'error', cb: (data:any)=>void): void;
  close(): Promise<void>;
}
export function createXnp(): Xnp;


Frame: { v:1, type:'DATA|ACK|NACK|CTRL', msgId, seq, total, window, ts, qos, fec?:{k,n}, payload? } (payload binário em base64url quando JSON).

Congestion: medir RTT por ACK.ts - sent.ts, aumentar/diminuir janela.

Safety: cifrar payload com AEAD (chacha20-poly1305) por sessão (chave vinda de handshake). Nunca invente cripto: use lib confiável.

/lib/xnp/fec.ts

Abstração FEC com encode(dataChunks, rate) -> chunks+parity e decode(chunks) -> data (reconstrói quando possível).

/lib/xnp/assembler.ts

Reassemblagem por msgId + seq, timeout de coleta, emissão quando complete.

/lib/xnp/bus.ts

Pub/Sub local: subscribe(topic, cb), publish(topic, data).

Opcional: backend Redis Streams quando REDIS_URL existir (para sistema “flutuante” multi-nó).

/lib/xnp/qos.ts

Perfis:

bronze: janela 8, FEC 10%, backlog 64.

prata: janela 16, FEC 20%, backlog 128.

ouro: janela 32, FEC 30%, backlog 256.

platina: janela 64, FEC 40%, backlog 512.

Se novo plano detectado (upgrade/downgrade), selecionar nova escala automaticamente alterando opts em runtime (hot-swap com suavização).

/lib/xnp/ai-recovery.ts

Interface: recoverText(partial: string, context: any): Promise<string>;

Implementar heurística local (n-gram/Markov) + opcional proxy LLM (ex.: OpenAI/Gemini) se AI_RECOVERY_ENABLED.

Só usar para tipos de dado tolerantes a predição. Nunca para registros críticos.

/lib/xnp/sim/lossy-sim.ts

Simulador de perda/latência/duplicação para testes: parâmetros de % perda, jitter, reordering.

Sinalização WebSocket

app/api/xnp/signaling/route.ts: upgrade WS (ou usar ws em server), autenticar sessão via cookie, iniciar XNP server-side.

8) Segurança (anti-hack real)

Headers em next.config.js:

const securityHeaders = [
  { key: 'Content-Security-Policy', value:
    "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https://firestore.googleapis.com https://identitytoolkit.googleapis.com https://securetoken.googleapis.com wss:; frame-ancestors 'none'; base-uri 'none'; object-src 'none';" },
  { key: 'Strict-Transport-Security', value: 'max-age=63072000; includeSubDomains; preload' },
  { key: 'X-Content-Type-Options', value: 'nosniff' },
  { key: 'Referrer-Policy', value: 'no-referrer' },
  { key: 'Permissions-Policy', value: 'geolocation=(), microphone=(), camera=()' },
  { key: 'Cross-Origin-Opener-Policy', value: 'same-origin' },
  { key: 'Cross-Origin-Resource-Policy', value: 'same-site' },
];
module.exports = { async headers() { return [{ source: '/(.*)', headers: securityHeaders }]; }, };


Session: cookie __Host-nextSession HttpOnly.

Rate-limit: login e APIs sensíveis (Redis/Upstash + fallback LRU).

CSRF: cookie csrf + header x-csrf-token.

Turnstile/ReCAPTCHA no login.

Honeypots: app/api/xnp/honeypot/route.ts registra IP/UA/timestamp no Auditoria/Honeypot/Hits (cadeia de auditoria com hash encadeado).

MFA para contas com role elevado.

Provedores Auth: desabilitar os não usados; exigir emailVerified para gravações.

Supply-chain: dependências pinadas, npm audit no CI, sem eval/dangerouslySetInnerHTML.

9) Sistema flutuante (multi-nó, tolerante a falhas)

Stateless: toda sessão XNP autenticada por cookie; metadados efêmeros replicáveis.

Bus com Redis Streams quando disponível; fallback in-memory.

Consistent hashing para shardar sessões XNP entre nós (hash por userId/empresaId).

Heartbeats/ping em XNP; auto-reconnect com backoff exponencial; reenvio de chunks pendentes.

Backpressure: quando congestionado, degrade QoS (reduz janela, aumenta FEC).

10) Testes automáticos

Unitários: transport, fec, assembler, qos.

Property-based (fast-check): gerador de sequências com perda/duplicação/reordering para validar reassemblagem determinística e idempotência.

Fuzz: aleatorizar frames corrompidos; sistema deve falhar de forma segura, jamais travar.

Integração: cliente/servidor XNP com lossy-sim configurável (p.ex. 15% perda, jitter 50-200ms).

E2E: fluxo login → criação de sessão → envio de payload grande (≥ 2MB) → valida reconstrução; repetir por QoS Bronze/Prata/Ouro/Platina.

Segurança: teste cabeçalhos HTTP, bloqueios em endpoints admin, MFA exigida para admin*.

11) Critérios de aceite (automáticos)

/home, /planos, /sistemas e todas as /.../auth abrem sem login (UI pública), sem erros de permissão; conteúdo privado só após user && claimsLoaded.

Session Cookie criado e validado; nenhum token exposto no client.

Rules aplicadas; acesso respeita empresaId + role.

XNP:

Reenvio seletivo (ACK/NACK) funcionando;

FEC reconstruindo até n% de perda por perfil;

Reassemblagem determinística;

QoS muda dinamicamente quando o plano do usuário muda;

Simulador com perda 10–30% mantém throughput, com degradação elegante;

AI Recovery (quando ativado) preenche texto parcial com acurácia ≥ baseline n-gram.

Rate-limit ativo no login, honeypot logando acessos suspeitos.

CI rodando typecheck, lint, test, audit:prod.

12) Entregáveis

Código completo de XNP (transport, fec, assembler, bus, qos, ai-recovery, lossy-sim).

Páginas /auth públicas com guard de conteúdo privado via dynamic import.

Session API (/api/session) + set-claims admin.

Rules: firebase.rules, storage.rules.

next.config.js com headers de segurança.

Testes (/tests/*.spec.ts) e SECURITY.md.

Pipelines CI prontos (test + audit).

13) Comandos finais

npm run typecheck

npm run test (inclui property-based/fuzz)

npm run audit:prod

Build e deploy (Vercel).

14) Notas de risco e limites

Cripto: use libs bem testadas. Não invente cifra.

AI Recovery é opcional e não deve alterar dados críticos; use só em fluxos tolerantes (texto/telemetria).

Vercel/WS: protocolo XNP roda sobre WebSockets (não UDP). Ajuste limites de payload.