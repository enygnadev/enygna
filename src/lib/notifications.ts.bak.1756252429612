import { db } from './firebase';
import { 
  collection, 
  doc, 
  setDoc, 
  getDocs, 
  query, 
  where, 
  orderBy, 
  limit,
  serverTimestamp,
  onSnapshot,
  Unsubscribe
} from 'firebase/firestore';
import { format } from 'date-fns';
import { ptBR } from 'date-fns/locale';


interface Notification {
  id: string;
  type: 'info' | 'success' | 'warning' | 'error' | 'security' | 'business';
  title: string;
  message: string;
  userId?: string;
  empresaId?: string;
  role?: string;
  priority: 'low' | 'medium' | 'high' | 'urgent';
  read: boolean;
  actionUrl?: string;
  actionLabel?: string;
  metadata?: Record<string, any>;
  createdAt: Date;
  expiresAt?: Date;
  channels: NotificationChannel[];
}

interface NotificationChannel {
  type: 'in_app' | 'email' | 'sms' | 'push' | 'webhook';
  enabled: boolean;
  config?: Record<string, any>;
}

interface NotificationTemplate {
  id: string;
  name: string;
  type: Notification['type'];
  subject: string;
  bodyTemplate: string;
  variables: string[];
  channels: NotificationChannel[];
  conditions?: Record<string, any>;
}

interface NotificationPreferences {
  userId: string;
  channels: {
    in_app: boolean;
    email: boolean;
    sms: boolean;
    push: boolean;
  };
  frequency: {
    immediate: boolean;
    daily_digest: boolean;
    weekly_digest: boolean;
  };
  types: {
    security: boolean;
    business: boolean;
    system: boolean;
    marketing: boolean;
  };
}

class NotificationService {
  private templates = new Map<string, NotificationTemplate>();
  private listeners = new Map<string, Unsubscribe>();
  private queue: Notification[] = [];
  private isProcessing = false;

  // Inicializar servi√ßo
  async initialize(): Promise<void> {
    console.log('üîî Inicializando servi√ßo de notifica√ß√µes...');

    await this.loadTemplates();
    await this.setupServiceWorker();
    this.startQueueProcessor();

    console.log('‚úÖ Servi√ßo de notifica√ß√µes inicializado');
  }

  // Carregar templates
  private async loadTemplates(): Promise<void> {
    try {
      const snapshot = await getDocs(collection(db, 'notification_templates'));
      snapshot.docs.forEach(doc => {
        const template = { id: doc.id, ...doc.data() } as NotificationTemplate;
        this.templates.set(template.id, template);
      });

      console.log(`üìã ${this.templates.size} templates de notifica√ß√£o carregados`);
    } catch (error) {
      console.error('Erro ao carregar templates:', error);
    }
  }

  // Configurar Service Worker para push notifications
  private async setupServiceWorker(): Promise<void> {
    if ('serviceWorker' in navigator && 'PushManager' in window) {
      try {
        const registration = await navigator.serviceWorker.register('/sw.js');
        console.log('üì± Service Worker registrado para push notifications');

        // Solicitar permiss√£o para notifica√ß√µes
        if (Notification.permission === 'default') {
          const permission = await Notification.requestPermission();
          console.log(`üîî Permiss√£o de notifica√ß√£o: ${permission}`);
        }
      } catch (error) {
        console.error('Erro ao configurar Service Worker:', error);
      }
    }
  }

  // Processar fila de notifica√ß√µes
  private startQueueProcessor(): void {
    setInterval(async () => {
      if (this.queue.length > 0 && !this.isProcessing) {
        await this.processQueue();
      }
    }, 1000); // Processar a cada segundo
  }

  // Processar fila
  private async processQueue(): Promise<void> {
    this.isProcessing = true;

    try {
      const notifications = this.queue.splice(0, 10); // Processar at√© 10 por vez

      for (const notification of notifications) {
        await this.deliverNotification(notification);
      }
    } catch (error) {
      console.error('Erro ao processar fila de notifica√ß√µes:', error);
    } finally {
      this.isProcessing = false;
    }
  }

  // Entregar notifica√ß√£o
  private async deliverNotification(notification: Notification): Promise<void> {
    for (const channel of notification.channels) {
      if (!channel.enabled) continue;

      try {
        switch (channel.type) {
          case 'in_app':
            await this.sendInAppNotification(notification);
            break;
          case 'email':
            await this.sendEmailNotification(notification, channel.config);
            break;
          case 'sms':
            await this.sendSMSNotification(notification, channel.config);
            break;
          case 'push':
            await this.sendPushNotification(notification);
            break;
          case 'webhook':
            await this.sendWebhookNotification(notification, channel.config);
            break;
        }
      } catch (error) {
        console.error(`Erro ao enviar notifica√ß√£o via ${channel.type}:`, error);
      }
    }
  }

  // Notifica√ß√£o in-app
  private async sendInAppNotification(notification: Notification): Promise<void> {
    try {
      const notificationDoc = doc(collection(db, 'notifications'));
      await setDoc(notificationDoc, {
        ...notification,
        id: notificationDoc.id,
        createdAt: serverTimestamp(),
        delivered: true,
        deliveredAt: serverTimestamp()
      });
    } catch (error) {
      console.error('Erro ao salvar notifica√ß√£o in-app:', error);
    }
  }

  // Notifica√ß√£o push
  private async sendPushNotification(notification: Notification): Promise<void> {
    if (!('serviceWorker' in navigator) || Notification.permission !== 'granted') {
      return;
    }

    try {
      const registration = await navigator.serviceWorker.ready;

      await registration.showNotification(notification.title, {
        body: notification.message,
        icon: '/icon-192x192.png',
        badge: '/badge-72x72.png',
        tag: notification.id,
        data: {
          url: notification.actionUrl,
          notificationId: notification.id
        },
        requireInteraction: notification.priority === 'urgent'
      });
    } catch (error) {
      console.error('Erro ao enviar push notification:', error);
    }
  }

  // Notifica√ß√£o por email (simulada)
  private async sendEmailNotification(notification: Notification, config?: Record<string, any>): Promise<void> {
    console.log('üìß Email notification:', {
      to: config?.email,
      subject: notification.title,
      body: notification.message
    });

    // Em produ√ß√£o, integrar com servi√ßo de email como SendGrid, AWS SES, etc.
  }

  // Notifica√ß√£o por SMS (simulada)
  private async sendSMSNotification(notification: Notification, config?: Record<string, any>): Promise<void> {
    console.log('üì± SMS notification:', {
      to: config?.phone,
      message: `${notification.title}: ${notification.message}`
    });

    // Em produ√ß√£o, integrar com servi√ßo de SMS como Twilio, AWS SNS, etc.
  }

  // Webhook notification
  private async sendWebhookNotification(notification: Notification, config?: Record<string, any>): Promise<void> {
    if (!config?.url) return;

    try {
      await fetch(config.url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(config.headers || {})
        },
        body: JSON.stringify({
          notification,
          timestamp: new Date().toISOString()
        })
      });
    } catch (error) {
      console.error('Erro ao enviar webhook:', error);
    }
  }

  // Criar notifica√ß√£o
  async createNotification(notification: Omit<Notification, 'id' | 'createdAt' | 'read'>): Promise<string> {
    const id = `notification_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    const fullNotification: Notification = {
      ...notification,
      id,
      createdAt: new Date(),
      read: false
    };

    // Adicionar √† fila para processamento
    this.queue.push(fullNotification);

    return id;
  }

  // Criar notifica√ß√£o usando template
  async createFromTemplate(
    templateId: string, 
    variables: Record<string, any>,
    recipients: {
      userId?: string;
      empresaId?: string;
      role?: string;
    }
  ): Promise<string> {
    const template = this.templates.get(templateId);
    if (!template) {
      throw new Error(`Template ${templateId} n√£o encontrado`);
    }

    // Substituir vari√°veis no template
    let message = template.bodyTemplate;
    let title = template.subject;

    for (const [key, value] of Object.entries(variables)) {
      const placeholder = `{{${key}}}`;
      message = message.replace(new RegExp(placeholder, 'g'), String(value));
      title = title.replace(new RegExp(placeholder, 'g'), String(value));
    }

    return await this.createNotification({
      type: template.type,
      title,
      message,
      priority: 'medium',
      channels: template.channels,
      metadata: {
        templateId,
        variables
      },
      ...recipients
    });
  }

  // Buscar notifica√ß√µes do usu√°rio
  async getUserNotifications(
    userId: string, 
    options: {
      unreadOnly?: boolean;
      limit?: number;
      types?: Notification['type'][];
    } = {}
  ): Promise<Notification[]> {
    try {
      let q = query(
        collection(db, 'notifications'),
        where('userId', '==', userId),
        orderBy('createdAt', 'desc')
      );

      if (options.unreadOnly) {
        q = query(q, where('read', '==', false));
      }

      if (options.types && options.types.length > 0) {
        q = query(q, where('type', 'in', options.types));
      }

      if (options.limit) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        q = query(q, limit(options.limit as any));
      }

      const snapshot = await getDocs(q);
      return snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt?.toDate() || new Date()
      })) as Notification[];
    } catch (error) {
      console.error('Erro ao buscar notifica√ß√µes do usu√°rio:', error);
      return [];
    }
  }

  // Marcar como lida
  async markAsRead(notificationId: string): Promise<void> {
    try {
      const notificationDoc = doc(db, 'notifications', notificationId);
      await setDoc(notificationDoc, {
        read: true,
        readAt: serverTimestamp()
      }, { merge: true });
    } catch (error) {
      console.error('Erro ao marcar notifica√ß√£o como lida:', error);
    }
  }

  // Marcar todas como lidas
  async markAllAsRead(userId: string): Promise<void> {
    try {
      const q = query(
        collection(db, 'notifications'),
        where('userId', '==', userId),
        where('read', '==', false)
      );

      const snapshot = await getDocs(q);

      for (const docSnapshot of snapshot.docs) {
        await setDoc(docSnapshot.ref, {
          read: true,
          readAt: serverTimestamp()
        }, { merge: true });
      }
    } catch (error) {
      console.error('Erro ao marcar todas como lidas:', error);
    }
  }

  // Escutar notifica√ß√µes em tempo real
  subscribeToNotifications(
    userId: string, 
    callback: (notifications: Notification[]) => void
  ): () => void {
    const q = query(
      collection(db, 'notifications'),
      where('userId', '==', userId),
      where('read', '==', false),
      orderBy('createdAt', 'desc'),
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      limit(20 as any)
    );

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const notifications = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt?.toDate() || new Date()
      })) as Notification[];

      callback(notifications);
    });

    this.listeners.set(userId, unsubscribe);

    return () => {
      unsubscribe();
      this.listeners.delete(userId);
    };
  }

  // Notifica√ß√µes pr√©-definidas para eventos do sistema
  async notifySessionApproved(sessionId: string, userId: string, empresaId: string): Promise<void> {
    await this.createNotification({
      type: 'success',
      title: 'Sess√£o Aprovada',
      message: 'Sua sess√£o de ponto foi aprovada pelo gestor.',
      userId,
      empresaId,
      priority: 'medium',
      channels: [
        { type: 'in_app', enabled: true },
        { type: 'push', enabled: true }
      ],
      metadata: { sessionId }
    });
  }

  async notifySessionRejected(sessionId: string, userId: string, empresaId: string, reason?: string): Promise<void> {
    await this.createNotification({
      type: 'warning',
      title: 'Sess√£o Rejeitada',
      message: `Sua sess√£o de ponto foi rejeitada${reason ? `: ${reason}` : '.'}`,
      userId,
      empresaId,
      priority: 'high',
      channels: [
        { type: 'in_app', enabled: true },
        { type: 'push', enabled: true }
      ],
      metadata: { sessionId, reason }
    });
  }

  async notifySecurityAlert(userId: string, alertType: string, details: string): Promise<void> {
    await this.createNotification({
      type: 'security',
      title: 'Alerta de Seguran√ßa',
      message: `${alertType}: ${details}`,
      userId,
      priority: 'urgent',
      channels: [
        { type: 'in_app', enabled: true },
        { type: 'push', enabled: true },
        { type: 'email', enabled: true }
      ],
      metadata: { alertType, details }
    });
  }

  async notifySystemMaintenance(startTime: Date, endTime: Date): Promise<void> {
    // Notificar todos os usu√°rios
    await this.createNotification({
      type: 'warning',
      title: 'Manuten√ß√£o Programada',
      message: `Sistema estar√° em manuten√ß√£o de ${startTime.toLocaleString()} at√© ${endTime.toLocaleString()}.`,
      priority: 'high',
      channels: [
        { type: 'in_app', enabled: true },
        { type: 'push', enabled: true }
      ],
      metadata: { startTime, endTime }
    });
  }

  async notifyPayrollGenerated(userId: string, empresaId: string, period: string, amount: number): Promise<void> {
    await this.createNotification({
      type: 'business',
      title: 'Holerite Gerado',
      message: `Seu holerite de ${period} est√° dispon√≠vel. Valor: R$ ${amount.toFixed(2)}`,
      userId,
      empresaId,
      priority: 'medium',
      actionUrl: '/colaborador/dashboard?tab=holerites',
      actionLabel: 'Ver Holerite',
      channels: [
        { type: 'in_app', enabled: true },
        { type: 'push', enabled: true },
        { type: 'email', enabled: true }
      ],
      metadata: { period, amount }
    });
  }

  // Obter estat√≠sticas de notifica√ß√µes
  async getNotificationStats(userId?: string): Promise<{
    total: number;
    unread: number;
    byType: Record<string, number>;
    byPriority: Record<string, number>;
  }> {
    try {
      let q = query(collection(db, 'notifications'));

      if (userId) {
        q = query(q, where('userId', '==', userId));
      }

      const snapshot = await getDocs(q);
      const notifications = snapshot.docs.map(doc => doc.data()) as Notification[];

      const stats = {
        total: notifications.length,
        unread: notifications.filter(n => !n.read).length,
        byType: {} as Record<string, number>,
        byPriority: {} as Record<string, number>
      };

      notifications.forEach(notification => {
        stats.byType[notification.type] = (stats.byType[notification.type] || 0) + 1;
        stats.byPriority[notification.priority] = (stats.byPriority[notification.priority] || 0) + 1;
      });

      return stats;
    } catch (error) {
      console.error('Erro ao obter estat√≠sticas:', error);
      return {
        total: 0,
        unread: 0,
        byType: {},
        byPriority: {}
      };
    }
  }

  // Processar fila de emails
  async processEmailQueue(): Promise<void> {
    console.log('üìß Processando fila de emails...');
    
    try {
      // Processar notifica√ß√µes pendentes na fila
      if (this.queue.length > 0) {
        await this.processQueue();
      }
      
      console.log('‚úÖ Fila de emails processada');
    } catch (error) {
      console.error('Erro ao processar fila de emails:', error);
    }
  }

  // Verificar atrasos
  async checkForDelays(): Promise<void> {
    console.log('‚è∞ Verificando atrasos...');
    
    try {
      // Aqui voc√™ implementaria a l√≥gica para verificar atrasos
      // Por exemplo, consultar sess√µes de ponto em andamento
      // e verificar se h√° atrasos significativos
      
      console.log('‚úÖ Verifica√ß√£o de atrasos conclu√≠da');
    } catch (error) {
      console.error('Erro ao verificar atrasos:', error);
    }
  }

  // Verificar aus√™ncias
  async checkForAbsences(): Promise<void> {
    console.log('üö´ Verificando aus√™ncias...');
    
    try {
      // Aqui voc√™ implementaria a l√≥gica para verificar aus√™ncias
      // Por exemplo, verificar funcion√°rios que n√£o bateram ponto
      // em hor√°rios esperados
      
      console.log('‚úÖ Verifica√ß√£o de aus√™ncias conclu√≠da');
    } catch (error) {
      console.error('Erro ao verificar aus√™ncias:', error);
    }
  }

  // Limpar listeners
  cleanup(): void {
    this.listeners.forEach(unsubscribe => unsubscribe());
    this.listeners.clear();
  }
}

// Inst√¢ncia global do servi√ßo
export const notificationService = new NotificationService();

// Hook para notifica√ß√µes (apenas TypeScript)
export interface UseNotificationsReturn {
  notifications: Notification[];
  loading: boolean;
  unreadCount: number;
  markAsRead: (notificationId: string) => Promise<void>;
  markAllAsRead: () => Promise<void>;
  createNotification: (notification: Omit<Notification, 'id' | 'createdAt' | 'read'>) => Promise<string>;
  getUserNotifications: (userId: string, options?: {
    unreadOnly?: boolean;
    limit?: number;
    types?: Notification['type'][];
  }) => Promise<Notification[]>;
}

export function createNotificationsHook() {
  return {
    useNotifications: (userId?: string): UseNotificationsReturn => {
      const formatDate = (timestamp: number) => {
        return format(new Date(timestamp), 'dd/MM/yyyy HH:mm', { locale: ptBR });
      };

      // Note: This should be moved to a React component if UI is needed
      return {
        formatDate,
        // Return notification service methods
        createNotification: notificationService.createNotification.bind(notificationService),
        markAsRead: notificationService.markAsRead.bind(notificationService),
        getUserNotifications: notificationService.getUserNotifications.bind(notificationService)
      };
    }
  };
}