
// src/lib/lgpd.ts - Sistema Completo de Conformidade LGPD
import React, { useState, useEffect } from 'react';
import { db } from '@/lib/firebase';
import { 
  collection, 
  doc, 
  setDoc, 
  getDoc, 
  updateDoc, 
  deleteDoc, 
  query, 
  where, 
  getDocs,
  serverTimestamp,
  writeBatch 
} from 'firebase/firestore';

export interface LGPDConsent {
  userId: string;
  consentType: 'essential' | 'analytics' | 'marketing' | 'functional';
  granted: boolean;
  timestamp: any;
  ipAddress?: string;
  userAgent?: string;
  version: string;
  purpose: string;
  legalBasis: 'consent' | 'contract' | 'legal_obligation' | 'vital_interests' | 'public_task' | 'legitimate_interests';
}

export interface DataProcessingRecord {
  id: string;
  userId: string;
  dataType: string;
  purpose: string;
  legalBasis: string;
  processor: string;
  retention: string;
  timestamp: any;
  location: string;
}

export interface PrivacySettings {
  userId: string;
  dataMinimization: boolean;
  pseudonymization: boolean;
  encryption: boolean;
  accessLogging: boolean;
  automaticDeletion: boolean;
  retentionPeriod: number; // em dias
  lastUpdated: any;
}

class LGPDService {
  // Registrar consentimento do usuário
  async recordConsent(consent: LGPDConsent): Promise<void> {
    try {
      const consentRef = doc(collection(db, 'lgpd_consents'));
      await setDoc(consentRef, {
        ...consent,
        timestamp: serverTimestamp(),
        version: '1.0.0',
        ipAddress: await this.getClientIP(),
        userAgent: navigator.userAgent
      });

      // Log da ação para auditoria
      await this.logDataAccess({
        userId: consent.userId,
        action: 'consent_recorded',
        dataType: 'consent',
        purpose: 'lgpd_compliance',
        timestamp: serverTimestamp()
      });
    } catch (error) {
      console.error('Erro ao registrar consentimento:', error);
      throw error;
    }
  }

  // Verificar consentimentos válidos
  async getValidConsents(userId: string): Promise<LGPDConsent[]> {
    try {
      const q = query(
        collection(db, 'lgpd_consents'),
        where('userId', '==', userId),
        where('granted', '==', true)
      );
      
      const snapshot = await getDocs(q);
      return snapshot.docs.map(doc => doc.data() as LGPDConsent);
    } catch (error) {
      console.error('Erro ao buscar consentimentos:', error);
      return [];
    }
  }

  // Revogar consentimento
  async revokeConsent(userId: string, consentType: string): Promise<void> {
    try {
      const q = query(
        collection(db, 'lgpd_consents'),
        where('userId', '==', userId),
        where('consentType', '==', consentType)
      );
      
      const snapshot = await getDocs(q);
      const batch = writeBatch(db);
      
      snapshot.docs.forEach(doc => {
        batch.update(doc.ref, {
          granted: false,
          revokedAt: serverTimestamp()
        });
      });
      
      await batch.commit();
      
      await this.logDataAccess({
        userId,
        action: 'consent_revoked',
        dataType: 'consent',
        purpose: 'user_request',
        timestamp: serverTimestamp()
      });
    } catch (error) {
      console.error('Erro ao revogar consentimento:', error);
      throw error;
    }
  }

  // Registrar processamento de dados
  async recordDataProcessing(record: Omit<DataProcessingRecord, 'id' | 'timestamp'>): Promise<void> {
    try {
      const recordRef = doc(collection(db, 'lgpd_processing_records'));
      await setDoc(recordRef, {
        ...record,
        id: recordRef.id,
        timestamp: serverTimestamp(),
        location: 'Brasil - Santa Catarina - Tubarão'
      });
    } catch (error) {
      console.error('Erro ao registrar processamento:', error);
      throw error;
    }
  }

  // Exportar dados do usuário (Direito de Portabilidade)
  async exportUserData(userId: string): Promise<any> {
    try {
      const userData: any = {};
      
      // Dados do usuário
      const userDoc = await getDoc(doc(db, 'users', userId));
      if (userDoc.exists()) {
        userData.profile = userDoc.data();
      }
      
      // Sessões de ponto
      const sessionsQuery = query(
        collection(db, `users/${userId}/sessions`)
      );
      const sessionsSnapshot = await getDocs(sessionsQuery);
      userData.sessions = sessionsSnapshot.docs.map(doc => doc.data());
      
      // Consentimentos
      const consentsQuery = query(
        collection(db, 'lgpd_consents'),
        where('userId', '==', userId)
      );
      const consentsSnapshot = await getDocs(consentsQuery);
      userData.consents = consentsSnapshot.docs.map(doc => doc.data());
      
      // Log da exportação
      await this.logDataAccess({
        userId,
        action: 'data_exported',
        dataType: 'all_user_data',
        purpose: 'user_request_portability',
        timestamp: serverTimestamp()
      });
      
      return {
        exportDate: new Date().toISOString(),
        userId,
        data: userData,
        dataController: {
          name: 'Cartão Ponto Web',
          cnpj: '00.000.000/0001-00', // Substitua pelo CNPJ real
          address: 'Tubarão, Santa Catarina, Brasil',
          dpo: 'dpo@cartaopontoweb.com.br'
        }
      };
    } catch (error) {
      console.error('Erro ao exportar dados:', error);
      throw error;
    }
  }

  // Excluir dados do usuário (Direito de Esquecimento)
  async deleteUserData(userId: string, reason: string): Promise<void> {
    try {
      const batch = writeBatch(db);
      
      // Log antes da exclusão
      await this.logDataAccess({
        userId,
        action: 'data_deletion_requested',
        dataType: 'all_user_data',
        purpose: reason,
        timestamp: serverTimestamp()
      });
      
      // Marcar para exclusão (soft delete) em vez de excluir imediatamente
      const userRef = doc(db, 'users', userId);
      batch.update(userRef, {
        deletedAt: serverTimestamp(),
        deletionReason: reason,
        dataRetentionExpires: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 dias
        anonymized: true,
        status: 'deleted'
      });
      
      await batch.commit();
      
      // Agendar exclusão física após período legal
      await this.schedulePhysicalDeletion(userId);
    } catch (error) {
      console.error('Erro ao excluir dados:', error);
      throw error;
    }
  }

  // Log de acesso a dados pessoais
  async logDataAccess(logEntry: {
    userId: string;
    action: string;
    dataType: string;
    purpose: string;
    timestamp: any;
    ipAddress?: string;
    userAgent?: string;
  }): Promise<void> {
    try {
      const logRef = doc(collection(db, 'lgpd_access_logs'));
      await setDoc(logRef, {
        ...logEntry,
        id: logRef.id,
        timestamp: serverTimestamp(),
        ipAddress: logEntry.ipAddress || await this.getClientIP(),
        userAgent: logEntry.userAgent || navigator.userAgent
      });
    } catch (error) {
      console.error('Erro ao registrar log de acesso:', error);
    }
  }

  // Configurar privacidade do usuário
  async updatePrivacySettings(userId: string, settings: Partial<PrivacySettings>): Promise<void> {
    try {
      const settingsRef = doc(db, 'lgpd_privacy_settings', userId);
      await setDoc(settingsRef, {
        userId,
        ...settings,
        lastUpdated: serverTimestamp()
      }, { merge: true });
      
      await this.logDataAccess({
        userId,
        action: 'privacy_settings_updated',
        dataType: 'privacy_preferences',
        purpose: 'user_configuration',
        timestamp: serverTimestamp()
      });
    } catch (error) {
      console.error('Erro ao atualizar configurações de privacidade:', error);
      throw error;
    }
  }

  // Verificar conformidade LGPD
  async checkCompliance(userId: string): Promise<{
    compliant: boolean;
    issues: string[];
    recommendations: string[];
  }> {
    const issues: string[] = [];
    const recommendations: string[] = [];
    
    try {
      // Verificar consentimentos válidos
      const consents = await this.getValidConsents(userId);
      if (consents.length === 0) {
        issues.push('Nenhum consentimento válido encontrado');
        recommendations.push('Solicitar consentimento do usuário');
      }
      
      // Verificar configurações de privacidade
      const settingsDoc = await getDoc(doc(db, 'lgpd_privacy_settings', userId));
      if (!settingsDoc.exists()) {
        issues.push('Configurações de privacidade não definidas');
        recommendations.push('Configurar preferências de privacidade');
      }
      
      // Verificar logs de acesso
      const logsQuery = query(
        collection(db, 'lgpd_access_logs'),
        where('userId', '==', userId)
      );
      const logsSnapshot = await getDocs(logsQuery);
      if (logsSnapshot.empty) {
        recommendations.push('Implementar logging de acesso a dados');
      }
      
      return {
        compliant: issues.length === 0,
        issues,
        recommendations
      };
    } catch (error) {
      console.error('Erro ao verificar conformidade:', error);
      return {
        compliant: false,
        issues: ['Erro ao verificar conformidade'],
        recommendations: ['Contactar suporte técnico']
      };
    }
  }

  // Agendar exclusão física de dados
  private async schedulePhysicalDeletion(userId: string): Promise<void> {
    try {
      const deletionRef = doc(collection(db, 'lgpd_scheduled_deletions'));
      await setDoc(deletionRef, {
        userId,
        scheduledDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 dias
        status: 'pending',
        createdAt: serverTimestamp()
      });
    } catch (error) {
      console.error('Erro ao agendar exclusão:', error);
    }
  }

  // Obter IP do cliente
  private async getClientIP(): Promise<string> {
    try {
      const response = await fetch('https://api.ipify.org?format=json');
      const data = await response.json();
      return data.ip;
    } catch {
      return 'unknown';
    }
  }

  // Gerar relatório de conformidade LGPD
  async generateComplianceReport(): Promise<any> {
    try {
      const report = {
        generatedAt: new Date().toISOString(),
        period: '30 dias',
        summary: {
          totalUsers: 0,
          activeConsents: 0,
          revokedConsents: 0,
          dataExports: 0,
          dataDeletions: 0,
          complianceIssues: 0
        },
        details: {
          consentMetrics: {},
          accessLogs: [],
          privacyRequests: [],
          securityIncidents: []
        }
      };
      
      // Implementar coleta de métricas
      // ... código para gerar relatório completo
      
      return report;
    } catch (error) {
      console.error('Erro ao gerar relatório:', error);
      throw error;
    }
  }
}

export const lgpdService = new LGPDService();

// Hooks para React
export function useLGPDConsent() {
  const [consents, setConsents] = useState<LGPDConsent[]>([]);
  const [loading, setLoading] = useState(true);
  
  const recordConsent = async (consent: Omit<LGPDConsent, 'timestamp'>) => {
    await lgpdService.recordConsent(consent as LGPDConsent);
  };
  
  const revokeConsent = async (userId: string, consentType: string) => {
    await lgpdService.revokeConsent(userId, consentType);
  };
  
  return {
    consents,
    loading,
    recordConsent,
    revokeConsent
  };
}

// Componente de Banner de Cookies/LGPD
export function LGPDConsentBanner({ userId }: { userId: string }) {
  const [showBanner, setShowBanner] = useState(false);
  const [consents, setConsents] = useState({
    essential: false,
    analytics: false,
    marketing: false,
    functional: false
  });
  
  useEffect(() => {
    // Verificar se já tem consentimentos
    const checkConsents = async () => {
      const validConsents = await lgpdService.getValidConsents(userId);
      if (validConsents.length === 0) {
        setShowBanner(true);
      }
    };
    
    if (userId) {
      checkConsents();
    }
  }, [userId]);
  
  const handleAcceptAll = async () => {
    for (const type of ['essential', 'analytics', 'marketing', 'functional'] as const) {
      await lgpdService.recordConsent({
        userId,
        consentType: type,
        granted: true,
        purpose: `Funcionalidades ${type}`,
        legalBasis: 'consent',
        version: '1.0.0'
      } as LGPDConsent);
    }
    setShowBanner(false);
  };
  
  const handleReject = async () => {
    await lgpdService.recordConsent({
      userId,
      consentType: 'essential',
      granted: true,
      purpose: 'Funcionalidades essenciais',
      legalBasis: 'legitimate_interests',
      version: '1.0.0'
    } as LGPDConsent);
    setShowBanner(false);
  };
  
  if (!showBanner) return null;
  
  return (
    <div style={{
      position: 'fixed',
      bottom: 0,
      left: 0,
      right: 0,
      background: 'rgba(0, 0, 0, 0.95)',
      color: 'white',
      padding: '1.5rem',
      zIndex: 10000,
      borderTop: '3px solid #3b82f6'
    }}>
      <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
        <h3 style={{ margin: '0 0 1rem 0', fontSize: '1.25rem', fontWeight: '600' }}>
          🍪 Privacidade e Proteção de Dados (LGPD)
        </h3>
        <p style={{ margin: '0 0 1rem 0', lineHeight: '1.5' }}>
          Respeitamos sua privacidade. Este site utiliza cookies e coleta dados pessoais conforme nossa 
          <a href="/privacy" style={{ color: '#3b82f6', marginLeft: '4px' }}>Política de Privacidade</a> e a 
          <strong> Lei Geral de Proteção de Dados (LGPD - Lei nº 13.709/2018)</strong>.
        </p>
        <p style={{ margin: '0 0 1.5rem 0', fontSize: '0.9rem', opacity: 0.9 }}>
          Você pode gerenciar suas preferências a qualquer momento.
        </p>
        <div style={{ display: 'flex', gap: '1rem', flexWrap: 'wrap' }}>
          <button
            onClick={handleAcceptAll}
            style={{
              padding: '0.75rem 1.5rem',
              background: '#22c55e',
              border: 'none',
              borderRadius: '6px',
              color: 'white',
              fontWeight: '500',
              cursor: 'pointer'
            }}
          >
            ✅ Aceitar Todos
          </button>
          <button
            onClick={handleReject}
            style={{
              padding: '0.75rem 1.5rem',
              background: 'transparent',
              border: '1px solid #6b7280',
              borderRadius: '6px',
              color: 'white',
              cursor: 'pointer'
            }}
          >
            ❌ Apenas Essenciais
          </button>
          <a
            href="/privacy-settings"
            style={{
              padding: '0.75rem 1.5rem',
              background: '#3b82f6',
              border: 'none',
              borderRadius: '6px',
              color: 'white',
              textDecoration: 'none',
              display: 'inline-block'
            }}
          >
            ⚙️ Personalizar
          </a>
        </div>
      </div>
    </div>
  );
}
