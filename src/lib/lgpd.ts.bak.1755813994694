
// src/lib/lgpd.ts - Sistema Completo de Conformidade LGPD
import React, { useState, useEffect } from 'react';
import { db } from '@/lib/firebase';
import { 
  collection, 
  doc, 
  setDoc, 
  getDoc, 
  updateDoc, 
  deleteDoc, 
  query, 
  where, 
  getDocs,
  serverTimestamp,
  writeBatch 
} from 'firebase/firestore';

export interface LGPDConsent {
  userId: string;
  consentType: 'essential' | 'analytics' | 'marketing' | 'functional';
  granted: boolean;
  timestamp: any;
  ipAddress?: string;
  userAgent?: string;
  version: string;
  purpose: string;
  legalBasis: 'consent' | 'contract' | 'legal_obligation' | 'vital_interests' | 'public_task' | 'legitimate_interests';
}

export interface DataProcessingRecord {
  id: string;
  userId: string;
  dataType: string;
  purpose: string;
  legalBasis: string;
  processor: string;
  retention: string;
  timestamp: any;
  location: string;
}

export interface PrivacySettings {
  userId: string;
  dataMinimization: boolean;
  pseudonymization: boolean;
  encryption: boolean;
  accessLogging: boolean;
  automaticDeletion: boolean;
  retentionPeriod: number; // em dias
  lastUpdated: any;
}

class LGPDService {
  // Registrar consentimento do usu√°rio
  async recordConsent(consent: LGPDConsent): Promise<void> {
    try {
      const consentRef = doc(collection(db, 'lgpd_consents'));
      await setDoc(consentRef, {
        ...consent,
        timestamp: serverTimestamp(),
        version: '1.0.0',
        ipAddress: await this.getClientIP(),
        userAgent: navigator.userAgent
      });

      // Log da a√ß√£o para auditoria
      await this.logDataAccess({
        userId: consent.userId,
        action: 'consent_recorded',
        dataType: 'consent',
        purpose: 'lgpd_compliance',
        timestamp: serverTimestamp()
      });
    } catch (error) {
      console.error('Erro ao registrar consentimento:', error);
      throw error;
    }
  }

  // Verificar consentimentos v√°lidos
  async getValidConsents(userId: string): Promise<LGPDConsent[]> {
    try {
      const q = query(
        collection(db, 'lgpd_consents'),
        where('userId', '==', userId),
        where('granted', '==', true)
      );
      
      const snapshot = await getDocs(q);
      return snapshot.docs.map(doc => doc.data() as LGPDConsent);
    } catch (error) {
      console.error('Erro ao buscar consentimentos:', error);
      return [];
    }
  }

  // Revogar consentimento
  async revokeConsent(userId: string, consentType: string): Promise<void> {
    try {
      const q = query(
        collection(db, 'lgpd_consents'),
        where('userId', '==', userId),
        where('consentType', '==', consentType)
      );
      
      const snapshot = await getDocs(q);
      const batch = writeBatch(db);
      
      snapshot.docs.forEach(doc => {
        batch.update(doc.ref, {
          granted: false,
          revokedAt: serverTimestamp()
        });
      });
      
      await batch.commit();
      
      await this.logDataAccess({
        userId,
        action: 'consent_revoked',
        dataType: 'consent',
        purpose: 'user_request',
        timestamp: serverTimestamp()
      });
    } catch (error) {
      console.error('Erro ao revogar consentimento:', error);
      throw error;
    }
  }

  // Registrar processamento de dados
  async recordDataProcessing(record: Omit<DataProcessingRecord, 'id' | 'timestamp'>): Promise<void> {
    try {
      const recordRef = doc(collection(db, 'lgpd_processing_records'));
      await setDoc(recordRef, {
        ...record,
        id: recordRef.id,
        timestamp: serverTimestamp(),
        location: 'Brasil - Santa Catarina - Tubar√£o'
      });
    } catch (error) {
      console.error('Erro ao registrar processamento:', error);
      throw error;
    }
  }

  // Exportar dados do usu√°rio (Direito de Portabilidade)
  async exportUserData(userId: string): Promise<any> {
    try {
      const userData: any = {};
      
      // Dados do usu√°rio
      const userDoc = await getDoc(doc(db, 'users', userId));
      if (userDoc.exists()) {
        userData.profile = userDoc.data();
      }
      
      // Sess√µes de ponto
      const sessionsQuery = query(
        collection(db, `users/${userId}/sessions`)
      );
      const sessionsSnapshot = await getDocs(sessionsQuery);
      userData.sessions = sessionsSnapshot.docs.map(doc => doc.data());
      
      // Consentimentos
      const consentsQuery = query(
        collection(db, 'lgpd_consents'),
        where('userId', '==', userId)
      );
      const consentsSnapshot = await getDocs(consentsQuery);
      userData.consents = consentsSnapshot.docs.map(doc => doc.data());
      
      // Log da exporta√ß√£o
      await this.logDataAccess({
        userId,
        action: 'data_exported',
        dataType: 'all_user_data',
        purpose: 'user_request_portability',
        timestamp: serverTimestamp()
      });
      
      return {
        exportDate: new Date().toISOString(),
        userId,
        data: userData,
        dataController: {
          name: 'Cart√£o Ponto Web',
          cnpj: '00.000.000/0001-00', // Substitua pelo CNPJ real
          address: 'Tubar√£o, Santa Catarina, Brasil',
          dpo: 'dpo@cartaopontoweb.com.br'
        }
      };
    } catch (error) {
      console.error('Erro ao exportar dados:', error);
      throw error;
    }
  }

  // Excluir dados do usu√°rio (Direito de Esquecimento)
  async deleteUserData(userId: string, reason: string): Promise<void> {
    try {
      const batch = writeBatch(db);
      
      // Log antes da exclus√£o
      await this.logDataAccess({
        userId,
        action: 'data_deletion_requested',
        dataType: 'all_user_data',
        purpose: reason,
        timestamp: serverTimestamp()
      });
      
      // Marcar para exclus√£o (soft delete) em vez de excluir imediatamente
      const userRef = doc(db, 'users', userId);
      batch.update(userRef, {
        deletedAt: serverTimestamp(),
        deletionReason: reason,
        dataRetentionExpires: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 dias
        anonymized: true,
        status: 'deleted'
      });
      
      await batch.commit();
      
      // Agendar exclus√£o f√≠sica ap√≥s per√≠odo legal
      await this.schedulePhysicalDeletion(userId);
    } catch (error) {
      console.error('Erro ao excluir dados:', error);
      throw error;
    }
  }

  // Log de acesso a dados pessoais
  async logDataAccess(logEntry: {
    userId: string;
    action: string;
    dataType: string;
    purpose: string;
    timestamp: any;
    ipAddress?: string;
    userAgent?: string;
  }): Promise<void> {
    try {
      const logRef = doc(collection(db, 'lgpd_access_logs'));
      await setDoc(logRef, {
        ...logEntry,
        id: logRef.id,
        timestamp: serverTimestamp(),
        ipAddress: logEntry.ipAddress || await this.getClientIP(),
        userAgent: logEntry.userAgent || navigator.userAgent
      });
    } catch (error) {
      console.error('Erro ao registrar log de acesso:', error);
    }
  }

  // Configurar privacidade do usu√°rio
  async updatePrivacySettings(userId: string, settings: Partial<PrivacySettings>): Promise<void> {
    try {
      const settingsRef = doc(db, 'lgpd_privacy_settings', userId);
      await setDoc(settingsRef, {
        userId,
        ...settings,
        lastUpdated: serverTimestamp()
      }, { merge: true });
      
      await this.logDataAccess({
        userId,
        action: 'privacy_settings_updated',
        dataType: 'privacy_preferences',
        purpose: 'user_configuration',
        timestamp: serverTimestamp()
      });
    } catch (error) {
      console.error('Erro ao atualizar configura√ß√µes de privacidade:', error);
      throw error;
    }
  }

  // Verificar conformidade LGPD
  async checkCompliance(userId: string): Promise<{
    compliant: boolean;
    issues: string[];
    recommendations: string[];
  }> {
    const issues: string[] = [];
    const recommendations: string[] = [];
    
    try {
      // Verificar consentimentos v√°lidos
      const consents = await this.getValidConsents(userId);
      if (consents.length === 0) {
        issues.push('Nenhum consentimento v√°lido encontrado');
        recommendations.push('Solicitar consentimento do usu√°rio');
      }
      
      // Verificar configura√ß√µes de privacidade
      const settingsDoc = await getDoc(doc(db, 'lgpd_privacy_settings', userId));
      if (!settingsDoc.exists()) {
        issues.push('Configura√ß√µes de privacidade n√£o definidas');
        recommendations.push('Configurar prefer√™ncias de privacidade');
      }
      
      // Verificar logs de acesso
      const logsQuery = query(
        collection(db, 'lgpd_access_logs'),
        where('userId', '==', userId)
      );
      const logsSnapshot = await getDocs(logsQuery);
      if (logsSnapshot.empty) {
        recommendations.push('Implementar logging de acesso a dados');
      }
      
      return {
        compliant: issues.length === 0,
        issues,
        recommendations
      };
    } catch (error) {
      console.error('Erro ao verificar conformidade:', error);
      return {
        compliant: false,
        issues: ['Erro ao verificar conformidade'],
        recommendations: ['Contactar suporte t√©cnico']
      };
    }
  }

  // Agendar exclus√£o f√≠sica de dados
  private async schedulePhysicalDeletion(userId: string): Promise<void> {
    try {
      const deletionRef = doc(collection(db, 'lgpd_scheduled_deletions'));
      await setDoc(deletionRef, {
        userId,
        scheduledDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 dias
        status: 'pending',
        createdAt: serverTimestamp()
      });
    } catch (error) {
      console.error('Erro ao agendar exclus√£o:', error);
    }
  }

  // Obter IP do cliente
  private async getClientIP(): Promise<string> {
    try {
      const response = await fetch('https://api.ipify.org?format=json');
      const data = await response.json();
      return data.ip;
    } catch {
      return 'unknown';
    }
  }

  // Gerar relat√≥rio de conformidade LGPD
  async generateComplianceReport(): Promise<any> {
    try {
      const report = {
        generatedAt: new Date().toISOString(),
        period: '30 dias',
        summary: {
          totalUsers: 0,
          activeConsents: 0,
          revokedConsents: 0,
          dataExports: 0,
          dataDeletions: 0,
          complianceIssues: 0
        },
        details: {
          consentMetrics: {},
          accessLogs: [],
          privacyRequests: [],
          securityIncidents: []
        }
      };
      
      // Implementar coleta de m√©tricas
      // ... c√≥digo para gerar relat√≥rio completo
      
      return report;
    } catch (error) {
      console.error('Erro ao gerar relat√≥rio:', error);
      throw error;
    }
  }
}

export const lgpdService = new LGPDService();

// Hooks para React
export function useLGPDConsent() {
  const [consents, setConsents] = useState<LGPDConsent[]>([]);
  const [loading, setLoading] = useState(true);
  
  const recordConsent = async (consent: Omit<LGPDConsent, 'timestamp'>) => {
    await lgpdService.recordConsent(consent as LGPDConsent);
  };
  
  const revokeConsent = async (userId: string, consentType: string) => {
    await lgpdService.revokeConsent(userId, consentType);
  };
  
  return {
    consents,
    loading,
    recordConsent,
    revokeConsent
  };
}

// Componente de Banner de Cookies/LGPD
export function LGPDConsentBanner({ userId }: { userId: string }) {
  const [showBanner, setShowBanner] = useState(false);
  const [consents, setConsents] = useState({
    essential: false,
    analytics: false,
    marketing: false,
    functional: false
  });
  
  useEffect(() => {
    // Verificar se j√° tem consentimentos
    const checkConsents = async () => {
      const validConsents = await lgpdService.getValidConsents(userId);
      if (validConsents.length === 0) {
        setShowBanner(true);
      }
    };
    
    if (userId) {
      checkConsents();
    }
  }, [userId]);
  
  const handleAcceptAll = async () => {
    for (const type of ['essential', 'analytics', 'marketing', 'functional'] as const) {
      await lgpdService.recordConsent({
        userId,
        consentType: type,
        granted: true,
        purpose: `Funcionalidades ${type}`,
        legalBasis: 'consent',
        version: '1.0.0'
      } as LGPDConsent);
    }
    setShowBanner(false);
  };
  
  const handleReject = async () => {
    await lgpdService.recordConsent({
      userId,
      consentType: 'essential',
      granted: true,
      purpose: 'Funcionalidades essenciais',
      legalBasis: 'legitimate_interests',
      version: '1.0.0'
    } as LGPDConsent);
    setShowBanner(false);
  };
  
  if (!showBanner) return null;
  
  return (
    <div style={{
      position: 'fixed',
      bottom: 0,
      left: 0,
      right: 0,
      background: 'rgba(0, 0, 0, 0.95)',
      color: 'white',
      padding: '1.5rem',
      zIndex: 10000,
      borderTop: '3px solid #3b82f6'
    }}>
      <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
        <h3 style={{ margin: '0 0 1rem 0', fontSize: '1.25rem', fontWeight: '600' }}>
          üç™ Privacidade e Prote√ß√£o de Dados (LGPD)
        </h3>
        <p style={{ margin: '0 0 1rem 0', lineHeight: '1.5' }}>
          Respeitamos sua privacidade. Este site utiliza cookies e coleta dados pessoais conforme nossa 
          <a href="/privacy" style={{ color: '#3b82f6', marginLeft: '4px' }}>Pol√≠tica de Privacidade</a> e a 
          <strong> Lei Geral de Prote√ß√£o de Dados (LGPD - Lei n¬∫ 13.709/2018)</strong>.
        </p>
        <p style={{ margin: '0 0 1.5rem 0', fontSize: '0.9rem', opacity: 0.9 }}>
          Voc√™ pode gerenciar suas prefer√™ncias a qualquer momento.
        </p>
        <div style={{ display: 'flex', gap: '1rem', flexWrap: 'wrap' }}>
          <button
            onClick={handleAcceptAll}
            style={{
              padding: '0.75rem 1.5rem',
              background: '#22c55e',
              border: 'none',
              borderRadius: '6px',
              color: 'white',
              fontWeight: '500',
              cursor: 'pointer'
            }}
          >
            ‚úÖ Aceitar Todos
          </button>
          <button
            onClick={handleReject}
            style={{
              padding: '0.75rem 1.5rem',
              background: 'transparent',
              border: '1px solid #6b7280',
              borderRadius: '6px',
              color: 'white',
              cursor: 'pointer'
            }}
          >
            ‚ùå Apenas Essenciais
          </button>
          <a
            href="/privacy-settings"
            style={{
              padding: '0.75rem 1.5rem',
              background: '#3b82f6',
              border: 'none',
              borderRadius: '6px',
              color: 'white',
              textDecoration: 'none',
              display: 'inline-block'
            }}
          >
            ‚öôÔ∏è Personalizar
          </a>
        </div>
      </div>
    </div>
  );
}
